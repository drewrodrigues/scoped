import db from "./db";
import moment from "moment";

export interface UnsavedModel {
  _id: string;
  type: string;
}

export interface SavedModel {
  _id: string;
  _rev: string;
  type: string;
}

export type UnsavedType<T> = T & UnsavedModel & Object;
type UnsavedConstructor<T> = T & Omit<UnsavedModel, "type" | "_id">;

export type SavedType<T> = T & SavedModel & Object;
type SavedConstructor<T> = T & Omit<SavedModel, "type">;

export interface IScope {
  title: string;
}

export type TrackingMethod = "yes/no" | "minutes" | "hours";

export interface IGoalTrackable extends IGoal {
  trackingMethod: TrackingMethod;
  trackingGoalQuantity: number;
}

export interface IGoal {
  title: string;
  scopeId: string;
  coverPhotoUrl?: string;

  // make these a pair
  startDate?: string;
  dueDate?: string;

  photoContainerId?: string;
  photoId?: string;
}

export interface ITracking {
  trackingMethod: TrackingMethod;
  value: number;
  createdOn: string;
  goalId: string;
}

export type TrackerType = "checkable" | "duration";

export interface IHabit {
  title: string;

  // make this specify only 1 parent
  scopeId?: string;
  goalId?: string;

  tracking: string[];
  tracker: TrackerType;
  archived?: boolean;
}

// TODO: implement
// export interface IGoalRequiredArgs {
//   title: string
// }

export abstract class CouchModel<T> {
  public static readonly typeName: string;

  private _isDirty: boolean;
  private _attributes: UnsavedType<T> | SavedType<T>;

  // TODO: @drew -- make this to where we don't have to pass the type
  // and simplify types overall. Can they be autogenerated for us?
  public static async all<S>() {
    console.info(`‚ÑπÔ∏è Getting all ${this.typeName}`);
    const response = await db.allDocs({
      startkey: `${this.typeName}`,
      endkey: `${this.typeName}\ufff0`,
      include_docs: true,
    });
    const docs = response.rows.map((row) => row.doc);
    console.log({ response, docs });
    return docs as unknown as SavedType<S>[];
  }

  constructor(attributes: UnsavedConstructor<T> | SavedType<T>) {
    if (!this._type)
      throw new Error("typeName must be defined in class definition");
    let _id: string;

    if (this.isSavedAttributes(attributes)) {
      console.log(`‚ÑπÔ∏è Init saved ${this._type} record`);
      _id = attributes._id;
      this._isDirty = false;
    } else {
      console.log(`‚ÑπÔ∏è Init new ${this._type} record`, { attributes });
      _id = `${this._type}-${Date.now().toString()}`;
      this._isDirty = true;
    }

    this._attributes = { type: this._type, ...attributes, _id };
  }

  public async save(parentRecord?: SavedType<any>) {
    // TODO: query and pull in latest revisions
    // to make sure there's no conflicts
    const newOrOld = this.isSavedAttributes(this._attributes) ? "old" : "new";

    if (parentRecord) {
      console.info("‚ÑπÔ∏è Will create record with parent record id", {
        parentRecord,
      });
    }

    try {
      console.info(`‚ÑπÔ∏è Creating ${newOrOld} ${this._type} record`, {
        attributes: this.attributes,
      });
      const createResponse = await db.put({
        ...this.attributes,
      });
      const createdRecord = {
        ...this.attributes,
        _rev: createResponse.rev,
        _id: createResponse.id,
      };
      console.info(`‚úÖ ${this._type} created`, {
        createResponse,
        createdRecord,
      });
      this._isDirty = false;
      return createdRecord as SavedType<T>;
    } catch (error) {
      console.error({ error }, "üö® Save failed");
      throw error;
    }
  }

  // TODO: clean up children
  public async destroy() {
    console.log("üóë Deleting a record with attributes: ", this.attributes);
    // TODO: improve with helper
    if (this.isSavedAttributes(this._attributes)) {
      await db.remove({
        _id: this._attributes._id,
        _rev: this._attributes._rev,
      });
    } else {
      throw new Error("üö® Cannot destroy an unsaved record");
    }
  }

  public setAttributes(attributes: SavedType<T>) {
    for (const key in attributes) {
      this._isDirty = true;
      this._attributes = attributes;
    }
  }

  public get attributes(): UnsavedType<T> | SavedType<T> {
    return this._attributes;
  }

  public get isDirty(): boolean {
    return this._isDirty;
  }

  private isSavedAttributes<T>(
    attributes: UnsavedConstructor<T> | SavedType<T>
  ): attributes is SavedType<T> {
    return !!(attributes as SavedType<T>)._rev;
  }

  private get _type(): string {
    // @ts-ignore
    return this.constructor.typeName;
  }

  public savableAttributes() {
    let keys = Object.keys(this);
    keys = keys.filter((key) => !key.startsWith("__"));
    const attributes = {};
    for (const key of keys) {
      // @ts-ignore
      attributes[key] = this[key];
    }
    // @ts-ignore
    return attributes;
  }
}

export class Goal extends CouchModel<IGoal> {
  public static readonly typeName = "Goal";

  //           methodName, foreignType, foreignKey
  // has_many 'habits', 'Habit', 'goalId'

  public async getTracking() {
    const tracking = await db.find({
      selector: {
        type: "Tracking",
        goalId: this.attributes._id,
      },
    });
    return tracking.docs as SavedType<ITracking>[];
  }

  // TODO: these should be done at the component level after data is returned
  // public get trackedQuantity(): number | string {
  //   let totalTracked = 0;
  //   if (
  //     this.attributes.tracking &&
  //     this.attributes.trackingType === "duration"
  //   ) {
  //     return Object.keys(this.attributes.tracking)
  //       .map((date) => parseInt(this.attributes.tracking[date]))
  //       .reduce((total, num) => total + num, 0);
  //   }
  //   return "Nothing to go";
  // }

  // public get isOnTrack(): boolean {
  //   return this.quantityShouldBeDone <= this.trackedQuantity;
  // }

  public get averageMinutesPerDayNeeded(): number {
    return (
      (parseInt(this.attributes.trackingGoalQuantity.split(":")[0]) * 60) /
      this.totalDaysToComplete
    );
  }

  // public get averageDurationPerDay(): number {}

  public get totalDaysToComplete(): number {
    return moment(this.attributes.dueDate).diff(
      this.attributes.startDate,
      "days"
    );
  }

  public get daysLeftUntilDue(): number {
    return moment(this.attributes.dueDate).diff(new Date(), "days");
  }

  public get timeUntilDue(): string {
    return moment(this.attributes.dueDate).fromNow();
  }

  public get elapsedDaysIntoGoal(): number {
    return this.totalDaysToComplete - this.daysLeftUntilDue;
  }

  public get quantityShouldBeDone(): number {
    return this.elapsedDaysIntoGoal * this.averageMinutesPerDayNeeded;
  }
}

export class Habit extends CouchModel<IHabit> {
  public static readonly typeName = "Scope";
}

export class Tracking extends CouchModel<ITracking> {
  public static readonly typeName = "Tracking";
}

export class Scope extends CouchModel<IScope> {
  public static readonly typeName = "Scope";
}
